name: Log Analysis & Improvement Suggestions

on:
  schedule:
    # Run every 4 hours
    - cron: '0 */4 * * *'
  workflow_dispatch:
    inputs:
      hours_to_analyze:
        description: 'Hours of logs to analyze'
        required: false
        default: '4'

jobs:
  analyze-logs:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/fff-key.pem
          chmod 600 ~/.ssh/fff-key.pem
          ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Collect logs from EC2
        id: collect-logs
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ec2-user
          HOURS_INPUT: ${{ github.event.inputs.hours_to_analyze }}
        run: |
          HOURS="${HOURS_INPUT:-4}"

          # Collect logs from the last N hours
          ssh -i ~/.ssh/fff-key.pem -o StrictHostKeyChecking=no \
            "$EC2_USER@$EC2_HOST" \
            "sudo journalctl -u funding-fee-farmer --since '${HOURS} hours ago' --no-pager 2>/dev/null | tail -500" \
            > /tmp/recent_logs.txt || true

          # Also get current service status
          ssh -i ~/.ssh/fff-key.pem -o StrictHostKeyChecking=no \
            "$EC2_USER@$EC2_HOST" \
            "sudo systemctl status funding-fee-farmer --no-pager 2>/dev/null | head -20" \
            > /tmp/service_status.txt || true

          # Count errors and warnings (handle grep returning 1 when no matches)
          ERROR_COUNT="$(grep -c -E 'ERROR|âŒ' /tmp/recent_logs.txt 2>/dev/null)" || ERROR_COUNT="0"
          WARN_COUNT="$(grep -c -E 'WARN|âš ' /tmp/recent_logs.txt 2>/dev/null)" || WARN_COUNT="0"

          # Write outputs
          {
            echo "error_count=${ERROR_COUNT}"
            echo "warn_count=${WARN_COUNT}"
            echo "hours=${HOURS}"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare analysis prompt
        id: prepare-prompt
        run: |
          # Read logs
          SERVICE_STATUS=$(cat /tmp/service_status.txt | head -50)
          RECENT_LOGS=$(cat /tmp/recent_logs.txt | tail -400)

          # Build prompt content and save to file for the action
          cat > /tmp/analysis_prompt.txt << PROMPT_EOF
          Analyze these funding fee farmer bot logs and identify potential improvements.

          ## Service Status
          \`\`\`
          ${SERVICE_STATUS}
          \`\`\`

          ## Recent Logs
          \`\`\`
          ${RECENT_LOGS}
          \`\`\`

          Please analyze and provide:
          1. **Health Assessment**: Is the bot running correctly? Any critical issues?
          2. **Error Analysis**: What errors occurred and their likely root causes?
          3. **Performance Observations**: Any patterns in timing, API calls, or resource usage?
          4. **Improvement Suggestions**: Specific code improvements that could be made

          For each improvement suggestion, rate it:
          - Priority: HIGH/MEDIUM/LOW
          - Effort: SMALL/MEDIUM/LARGE
          - Impact: Brief description of the benefit

          Format your response as JSON with this structure:
          \`\`\`json
          {
            "health_status": "healthy|degraded|critical",
            "summary": "Brief overall summary",
            "errors": [{"message": "...", "count": 1, "cause": "...", "fix": "..."}],
            "improvements": [
              {
                "title": "Short title for GitHub issue",
                "description": "Detailed description",
                "priority": "HIGH|MEDIUM|LOW",
                "effort": "SMALL|MEDIUM|LARGE",
                "impact": "What this improves",
                "files_to_modify": ["src/file.rs"],
                "suggested_approach": "How to implement this"
              }
            ]
          }
          \`\`\`
          PROMPT_EOF

          # Store prompt in output using delimiter for multiline
          echo "prompt<<PROMPT_DELIMITER" >> "$GITHUB_OUTPUT"
          cat /tmp/analysis_prompt.txt >> "$GITHUB_OUTPUT"
          echo "PROMPT_DELIMITER" >> "$GITHUB_OUTPUT"

      - name: Analyze logs with Claude
        id: analyze
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: ${{ steps.prepare-prompt.outputs.prompt }}
          claude_args: |
            --json-schema '{"type":"object","properties":{"health_status":{"type":"string","enum":["healthy","degraded","critical"]},"summary":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"message":{"type":"string"},"count":{"type":"integer"},"cause":{"type":"string"},"fix":{"type":"string"}}}},"improvements":{"type":"array","items":{"type":"object","properties":{"title":{"type":"string"},"description":{"type":"string"},"priority":{"type":"string","enum":["HIGH","MEDIUM","LOW"]},"effort":{"type":"string","enum":["SMALL","MEDIUM","LARGE"]},"impact":{"type":"string"},"files_to_modify":{"type":"array","items":{"type":"string"}},"suggested_approach":{"type":"string"}}}}},"required":["health_status","summary"]}'

      - name: Process structured output
        uses: actions/github-script@v7
        env:
          STRUCTURED_OUTPUT: ${{ steps.analyze.outputs.structured_output }}
          ERROR_COUNT: ${{ steps.collect-logs.outputs.error_count }}
          WARN_COUNT: ${{ steps.collect-logs.outputs.warn_count }}
        with:
          script: |
            const output = process.env.STRUCTURED_OUTPUT;
            console.log('Structured output received:', output ? output.length + ' chars' : 'empty');

            let analysis;
            try {
              if (!output || output.trim() === '') {
                throw new Error('Empty structured output');
              }
              analysis = JSON.parse(output);
              console.log('Successfully parsed structured output');
            } catch (e) {
              console.log('Failed to parse structured output:', e.message);
              const errorCount = parseInt(process.env.ERROR_COUNT) || 0;
              const warnCount = parseInt(process.env.WARN_COUNT) || 0;

              // Only create issue if there are actual problems
              if (errorCount > 0 || warnCount > 100) {
                const today = new Date().toISOString().split('T')[0];
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[Log Analysis] Review needed - ${today}`,
                  body: `## Automated Log Analysis\n\n**Errors**: ${errorCount}\n**Warnings**: ${warnCount}\n\nStructured output parsing failed. Raw output:\n\`\`\`\n${output || 'empty'}\n\`\`\``,
                  labels: ['log-analysis', 'needs-review']
                });
              }
              return;
            }

            // Log summary
            console.log(`Health: ${analysis.health_status}`);
            console.log(`Summary: ${analysis.summary}`);
            console.log(`Errors found: ${(analysis.errors || []).length}`);
            console.log(`Improvements: ${(analysis.improvements || []).length}`);

            // Helper to check for existing issues
            async function issueExists(labelFilter, titleSubstring) {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: labelFilter
              });
              return issues.data.some(i => i.title.includes(titleSubstring));
            }

            // CRITICAL/DEGRADED: Create urgent issue
            if (analysis.health_status === 'critical' || analysis.health_status === 'degraded') {
              const exists = await issueExists('urgent', analysis.health_status);
              if (!exists) {
                const errorsSection = (analysis.errors || [])
                  .map(e => `- **${e.message}** (${e.count || 1}x)\n  - Cause: ${e.cause || 'Unknown'}\n  - Fix: ${e.fix || 'TBD'}`)
                  .join('\n') || 'See logs for details';

                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `ðŸš¨ [URGENT] Bot health ${analysis.health_status.toUpperCase()}`,
                  body: `## Health: ${analysis.health_status.toUpperCase()}\n\n**Summary**: ${analysis.summary}\n\n### Errors\n${errorsSection}\n\n---\n*Auto-created by log analysis.*\n\n@claude please investigate.`,
                  labels: ['urgent', 'automated', analysis.health_status]
                });
                console.log(`Created urgent issue for ${analysis.health_status}`);
              }
            }

            // HEALTHY: Close stale review issues
            if (analysis.health_status === 'healthy') {
              const staleIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'needs-review'
              });
              for (const issue of staleIssues.data) {
                if (issue.title.includes('[Log Analysis]')) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'completed'
                  });
                  console.log(`Closed stale issue #${issue.number}`);
                }
              }
            }

            // HIGH priority improvements: Create issues
            const highPriority = (analysis.improvements || []).filter(i => i.priority === 'HIGH');
            for (const imp of highPriority) {
              const exists = await issueExists('claude-improvement', imp.title.substring(0, 30));
              if (!exists) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[Auto] ${imp.title}`,
                  body: `## Improvement Suggestion\n\n**Priority**: ${imp.priority} | **Effort**: ${imp.effort}\n**Impact**: ${imp.impact}\n\n### Description\n${imp.description}\n\n### Files\n${(imp.files_to_modify || []).map(f => '- `' + f + '`').join('\n') || '- TBD'}\n\n### Approach\n${imp.suggested_approach}\n\n---\n@claude please implement.`,
                  labels: ['claude-improvement', 'automated', 'high']
                });
                console.log(`Created: ${imp.title}`);
              }
            }

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/fff-key.pem
          rm -f /tmp/recent_logs.txt /tmp/service_status.txt
          rm -f /tmp/analysis_prompt.txt /tmp/analysis_result.txt
